extern crate clap;
extern crate gnuplot;
mod tools;
mod train;
mod predict;

use std::process;
use clap::{Arg, App, SubCommand};
use train::sub_training;
use predict::sub_predict;

fn main() {
    let matches = App::new("ft_linear_regression")
        .version("4.2")
        .author("hsabouri <hsabouri@student.42.fr>")
        .about("Does a linear regression on a dataset and can predict from this regression.")
        .subcommand(SubCommand::with_name("train")
            .arg(Arg::with_name("DATASET")
                 .help("Location of a .csv dataset file")
                 .required(true)
                 .index(1))
            .arg(Arg::with_name("learning_rate")
                 .short("r")
                 .long("learning_rate")
                 .help("Sets the learning rate of the algorithm.")
                 .takes_value(true)
                 .default_value("0.5"))
            .arg(Arg::with_name("iterations")
                 .short("i")
                 .long("iterations")
                 .help("Number of iteration")
                 .takes_value(true)
                 .default_value("500")))
        .subcommand(SubCommand::with_name("predict")
            .about("Uses a config file generated by the training algorithm and predict Y from X.")
            .arg(Arg::with_name("CONFIG_FILE")
                 .help("Location of the .csv config file")
                 .required(true)
                 .index(1))
            .arg(Arg::with_name("X")
                 .help("Single value to predict")
                 .takes_value(true))
            .arg(Arg::with_name("DATASET")
                 .help("CSV file containing a list of values to predict")
                 .short("f")
                 .long("file")
                 .takes_value(true)))
        .get_matches();

    if let Some(matches) = matches.subcommand_matches("train") {
        sub_training(matches);
    } else if let Some(matches) = matches.subcommand_matches("predict") {
        match sub_predict(matches) {
            Err(error) => {
                println!("{}", error);
            },
            _ => {}
        }
    } else {
        println!("{}", matches.usage());
        process::exit(1);
    }
}
